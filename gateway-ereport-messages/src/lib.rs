// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2025 Oxide Computer Company

//! Request and response types for the ereport ingestion protocol.
//!
//! This module defines both the request message sent by MGS
//! ([`EreportRequest`]), and the header for the response to that message by the
//! SP ([`EreportResponseHeader`]).
//!
//! For more information on the high-level design of the ereport ingestion
//! protocol, see [RFD 520] Control Plane Fault Ingestion and Data Model. For
//! details on the encoding of SP ereport messages, refer to [RFD 544] Embedded
//! E-report Formats and [RFD 545] Firmware E-report Aggregation and Evacuation.
//!
//! [RFD 520] https://rfd.shared.oxide.computer/rfd/520
//! [RFD 544] https://rfd.shared.oxide.computer/rfd/544
//! [RFD 545] https://rfd.shared.oxide.computer/rfd/545
#![cfg_attr(not(test), no_std)]

use zerocopy::{
    byteorder::little_endian as le, FromBytes, Immutable, IntoBytes,
    KnownLayout, TryFromBytes,
};

/// An error numeric identifier (ENA).
///
/// ENAs are 64-bit unsigned integers that uniquely identify an ereport within a
/// single reporter restart.
///
/// See [RFD 520 §1.1.1] for details.
///
/// [RFD 520 §1.1.1]: https://rfd.shared.oxide.computer/rfd/0520#enas
#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    Ord,
    PartialOrd,
    FromBytes,
    Immutable,
    IntoBytes,
    KnownLayout,
)]
#[repr(transparent)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(from = "u64", into = "u64"))]
pub struct Ena(pub le::U64);

#[cfg(any(feature = "debug-impls", test))]
impl core::fmt::Debug for Ena {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "Ena({:#x})", self.0)
    }
}

impl Ena {
    /// ENA 0 is reserved to represent "no ENA".
    pub const NONE: Self = Self(le::U64::ZERO);

    #[must_use]
    pub const fn new(u: u64) -> Self {
        Self(le::U64::new(u))
    }

    #[must_use]
    pub const fn into_u64(self) -> u64 {
        self.0.get()
    }
}

impl From<u64> for Ena {
    fn from(u: u64) -> Self {
        Self::new(u)
    }
}

impl From<Ena> for u64 {
    fn from(id: Ena) -> Self {
        id.into_u64()
    }
}

/// A unique identifier generated by the SP's snitch task when it starts up,
/// used to detect restarts.
///
/// See [RFD 520 §4.2.2] for details.
///
/// [RFD 520 §4.2.2]: https://rfd.shared.oxide.computer/rfd/0520#reporter-crash-recovery
#[derive(
    Clone, Copy, PartialEq, Eq, FromBytes, Immutable, IntoBytes, KnownLayout,
)]
#[repr(transparent)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
pub struct RestartId(pub le::U128);

impl RestartId {
    pub const ZERO: Self = Self(le::U128::ZERO);

    #[must_use]
    pub const fn new(u: u128) -> Self {
        Self(le::U128::new(u))
    }

    #[must_use]
    pub const fn into_u128(self) -> u128 {
        self.0.get()
    }
}

impl From<u128> for RestartId {
    fn from(u: u128) -> Self {
        Self::new(u)
    }
}

impl From<RestartId> for u128 {
    fn from(id: RestartId) -> Self {
        id.into_u128()
    }
}

/// A versioned request for ereports aggregated by the SP's snitch task.
///
/// See [RFD 545 §4.4.3.1] for details.
/// [RFD 545 §4.4.3.1]: https://rfd.shared.oxide.computer/rfd/0545#_requestcommit
#[derive(
    Clone, Copy, PartialEq, Eq, TryFromBytes, IntoBytes, KnownLayout, Immutable,
)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
#[repr(u8)]
// zerocopy-generated variant names fall afoul of this lint
#[allow(non_camel_case_types)]
pub enum Request {
    /// An ereport protocol version 0 request.
    ///
    /// The SP must respond to this request with a [`EreportResponseHeader::V0`]
    /// packet.
    V0(RequestV0) = 0,
    // IMPORTANT: when adding new variants to this enum, please add them to the
    // `version_byte_values` test below!
}

/// An ereport request ID (sequence number)
///
/// This is an arbitrary 8-bit value sent in the request packet. The SP is
/// expected to include this value in the header for the response packet.
#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    Ord,
    PartialOrd,
    FromBytes,
    Immutable,
    IntoBytes,
    KnownLayout,
)]
#[repr(transparent)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
pub struct RequestIdV0(pub u8);

impl RequestIdV0 {
    pub fn increment(&mut self) {
        self.0 = self.0.wrapping_add(1);
    }
}

/// A request for ereports aggregated by the SP's snitch task, version 0.
///
/// ```text
///     0         1        2        3
/// +--------+--------+--------+--------+
/// | version| limit  | req ID |        |
/// +--------+--------+--------+        +
/// |                                   |
/// +                                   +
/// |                                   |
/// +       restart ID (128 bits)       +
/// |                                   |
/// +                          *--------+
/// |                          |        |
/// +--------+--------+--------+        +
/// |   first ENA desired in response   |
/// +            (64 bits)     +--------+
/// |                          |        |
/// +--------+--------+--------+        *
/// |    last ENA written to database   | or 0, if no committed ENA exists
/// +            (64 bits)     +--------+ for this restart generation.
/// |                          |
/// +--------+--------+--------+
/// ```
///
/// See [RFD 545 §4.4.3.1] for details.
/// [RFD 545 §4.4.3.1]: https://rfd.shared.oxide.computer/rfd/0545#_requestcommit
#[derive(
    Clone, Copy, PartialEq, Eq, FromBytes, Immutable, IntoBytes, KnownLayout,
)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
pub struct RequestV0 {
    /// Maximum number of ereports to include in the response packet.
    pub limit: u8,

    /// Message ID of this request. The SP must include this value in the
    /// response header for the response to this request.
    pub request_id: RequestIdV0,

    /// The restart ID of the SP's snitch task which the control plane believes
    /// is current.
    ///
    /// If this value does not match the reporter's current restart ID, the
    /// reporter's response will include the current restart ID, and will start
    /// at the earliest known ENA, rather than the provided `start_ena`.
    ///
    /// If the control plane does not know the SP's restart ID, this will be 0. IDs
    /// generated by the snitch task on startup must not be 0.
    pub restart_id: RestartId,

    /// If present, the snitch should not include ENAs earlier than this one
    /// in its response, provided that the requested reporter generation matches
    /// the current generation.
    pub start_ena: Ena,

    /// The ENA of the last ereport committed to persistent storage from the
    /// requested reporter restart.
    ///
    /// If the restart ID parameter matches the reporter's current restart,
    /// it is permitted to discard any ereports with ENAs up to and including
    /// this value. If the restart ID has changed from the provided one, the
    /// reporter will not discard data.
    ///
    /// If this is zero, then no committed ENA is sent and the SP should not
    /// discard data.
    committed_ena: Ena,
}

/// Flags for [`EreportRequest`] packets.
#[derive(
    Clone, Copy, PartialEq, Eq, FromBytes, Immutable, IntoBytes, KnownLayout,
)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
#[repr(transparent)]
pub struct RequestFlagsV0(u8);

impl RequestV0 {
    pub const fn new(
        restart_id: RestartId,
        request_id: RequestIdV0,
        start_ena: Ena,
        limit: u8,
        committed_ena: Option<Ena>,
    ) -> Self {
        let committed_ena = match committed_ena {
            Some(ena) => ena,
            None => Ena::NONE,
        };
        Self { limit, request_id, restart_id, start_ena, committed_ena }
    }

    /// Returns the "committed ENA" field if this packet contains one.
    ///
    /// This checks the value of the [`RequestFlagsV0::COMMIT`] bit, and returns
    /// the ENA only if it is set.
    #[must_use]
    pub fn committed_ena(&self) -> Option<&Ena> {
        if self.committed_ena == Ena::NONE {
            None
        } else {
            Some(&self.committed_ena)
        }
    }
}

/// A versioned header for the response to an ereport [`Request`].
///
/// See [RFD 545 §4.4.3.1] for details.
/// [RFD 545 §4.4.3.1]: https://rfd.shared.oxide.computer/rfd/0545#_requestcommit
#[derive(
    Clone, Copy, PartialEq, Eq, TryFromBytes, IntoBytes, KnownLayout, Immutable,
)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
#[repr(u8)]
// zerocopy-generated variant names fall afoul of this lint
#[allow(non_camel_case_types)]
pub enum ResponseHeader {
    /// An ereport protocol version 0 response header.
    ///
    /// This is sent in response to a [`RequestV0`] message.
    V0(ResponseHeaderV0) = 0,
    // IMPORTANT: when adding new variants to this enum, please add them to the
    // `version_byte_values` test below!
}

/// Header for responses to [v0 ereport requests](RequestV0).
///
/// ```text
///     0         1        2        3
/// +--------+--------+--------+--------+
/// | version| req ID |                 |
/// +--------+--------+                 +
/// |                                   |
/// +                                   +
/// |       restart ID (128 bits)       |
/// +                                   +
/// |                                   |
/// +                 +--------+--------+
/// |                 |  start ENA      |
/// +--------+--------+--------+--------+
/// |    start ENA    |  0xBF  |
/// +--------+--------+--------+--------+
/// ... metadata k/v pairs ... |  0xFF  | metadata-only packets may end here
/// +--------+--------+--------+--------+
/// |  0x9F  | ... ereports ...|  0xFF  |
/// +--------+                 +--------+
/// ```
/// See [RFD 545 §4.4.4] for details.
/// [RFD 545 §4.4.4]: https://rfd.shared.oxide.computer/rfd/0545#_readresponse
#[derive(
    Clone, Copy, PartialEq, Eq, FromBytes, Immutable, IntoBytes, KnownLayout,
)]
#[cfg_attr(any(feature = "debug-impls", test), derive(Debug))]
pub struct ResponseHeaderV0 {
    /// The request ID of the request that this message is a response to.
    pub request_id: RequestIdV0,
    /// The reporter restart ID of the SP's snitch task when this response was
    /// produced.
    pub restart_id: RestartId,
    /// The ENA of the first ereport in the response packet.
    pub start_ena: Ena,
}

#[cfg(test)]
mod tests {
    use super::*;
    use core::fmt::Debug;

    struct PrettyBytes<'bytes>(&'bytes [u8]);
    impl Debug for PrettyBytes<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut bytes = self.0.iter();
            if let Some(byte) = bytes.next() {
                write!(f, "\n  {:02x}", byte)?;
                let mut written = 1;
                for byte in bytes {
                    write!(f, " {:02x}", byte)?;
                    written += 1;
                    if written % 8 == 0 {
                        f.write_str("\n ")?;
                    }
                }
                writeln!(f)?;
            }
            Ok(())
        }
    }

    impl core::ops::Deref for PrettyBytes<'_> {
        type Target = [u8];

        fn deref(&self) -> &Self::Target {
            self.0
        }
    }

    // Test that the "version" fields in the request and response messages have
    // the expected values.
    //
    // Hubpack serializes enums using single-byte tag values, determined in the
    // struct's declaration order. Because of this, changing the order of
    // variants of the versioned request and response enums (`EreportRequest`
    // and `EreportResponseHeader`) will change the versions they serialize as.
    // This test ensures we don't accidentally do that, provided that new
    // versions are added to this test.
    #[test]
    fn version_byte_values() {
        let reqv0 = Request::V0(RequestV0::new(
            RestartId::new(1),
            RequestIdV0(1),
            Ena::new(2),
            3,
            Some(Ena::new(4)),
        ));
        assert_eq!(
            reqv0.as_bytes()[0],
            0,
            "Request v0 version byte should be 0"
        );

        let rspv0 = ResponseHeader::V0(ResponseHeaderV0 {
            restart_id: RestartId::new(1),
            request_id: RequestIdV0(1),
            start_ena: Ena::new(1),
        });
        assert_eq!(
            rspv0.as_bytes()[0],
            0,
            "ResponseHeader v0 version byte should be 0"
        );

        // IMPORTANT: when adding new variants to the versioned message enums,
        // please add tests for them here!
    }

    #[track_caller]
    fn assert_roundtrips<M>(msg: M)
    where
        M: TryFromBytes + IntoBytes + Immutable + PartialEq + core::fmt::Debug,
    {
        let bytes = dbg!(&msg).as_bytes();
        let msg2 = dbg!(M::try_read_from_bytes(&*dbg!(PrettyBytes(bytes))))
            .expect("message should be valid");
        assert_eq!(msg, msg2);
    }

    #[test]
    fn request_v0_roundtrips() {
        assert_roundtrips(Request::V0(RequestV0::new(
            RestartId::new(0xdeadbeef),
            RequestIdV0(2),
            Ena::new(0xdecaff00d),
            4,
            None,
        )));
        assert_roundtrips(Request::V0(RequestV0::new(
            RestartId::new(1),
            RequestIdV0(2),
            Ena::new(3),
            4,
            Some(Ena::new(5)),
        )));
    }

    #[test]
    fn response_v0_roundtrips() {
        assert_roundtrips(ResponseHeader::V0(ResponseHeaderV0 {
            restart_id: RestartId::new(0xdeadbeef),
            request_id: RequestIdV0(2),
            start_ena: Ena::new(0xdecaff00d),
        }));
    }
}
